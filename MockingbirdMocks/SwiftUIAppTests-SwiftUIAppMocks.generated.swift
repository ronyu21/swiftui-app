//
//  SwiftUIAppTests-SwiftUIAppMocks.generated.swift
//  SwiftUIApp
//
//  Generated by Mockingbird v0.12.0.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import SwiftUIApp
import Combine
import CoreData
import CoreImage.CIFilterBuiltins
import Foundation
import Swift
import SwiftUI
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AppDelegate

public final class AppDelegateMock: SwiftUIApp.AppDelegate, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AppDelegateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked persistentContainer

  override public var `persistentContainer`: NSPersistentContainer {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "persistentContainer.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> NSPersistentContainer in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> NSPersistentContainer {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (NSPersistentContainer).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "persistentContainer.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (NSPersistentContainer) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getPersistentContainer() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> NSPersistentContainer, NSPersistentContainer> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "persistentContainer.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> NSPersistentContainer, NSPersistentContainer>(mock: self, invocation: invocation)
  }

  public func setPersistentContainer(_ newValue: @escaping @autoclosure () -> NSPersistentContainer) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (NSPersistentContainer) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "persistentContainer.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (NSPersistentContainer) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions)

  public override func `application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions) -> UISceneConfiguration {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions) -> UISceneConfiguration", arguments: [Mockingbird.ArgumentMatcher(`application`), Mockingbird.ArgumentMatcher(`connectingSceneSession`), Mockingbird.ArgumentMatcher(`options`)])
    return mockingContext.didInvoke(invocation) { () -> UISceneConfiguration in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIApplication, UISceneSession, UIScene.ConnectionOptions) -> UISceneConfiguration {
        return concreteImplementation(`application`, `connectingSceneSession`, `options`)
      } else if let concreteImplementation = implementation as? () -> UISceneConfiguration {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (UISceneConfiguration).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `application`(_ `application`: @escaping @autoclosure () -> UIApplication, `configurationForConnecting` `connectingSceneSession`: @escaping @autoclosure () -> UISceneSession, `options`: @escaping @autoclosure () -> UIScene.ConnectionOptions) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIApplication, UISceneSession, UIScene.ConnectionOptions) -> UISceneConfiguration, UISceneConfiguration> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`application`), Mockingbird.resolve(`connectingSceneSession`), Mockingbird.resolve(`options`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions) -> UISceneConfiguration", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIApplication, UISceneSession, UIScene.ConnectionOptions) -> UISceneConfiguration, UISceneConfiguration>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>)

  public override func `application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>) -> Void", arguments: [Mockingbird.ArgumentMatcher(`application`), Mockingbird.ArgumentMatcher(`sceneSessions`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIApplication, Set<UISceneSession>) -> Void {
        concreteImplementation(`application`, `sceneSessions`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `application`(_ `application`: @escaping @autoclosure () -> UIApplication, `didDiscardSceneSessions` `sceneSessions`: @escaping @autoclosure () -> Set<UISceneSession>) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIApplication, Set<UISceneSession>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`application`), Mockingbird.resolve(`sceneSessions`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIApplication, Set<UISceneSession>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?)

  public override func `application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`application`), Mockingbird.ArgumentMatcher(`launchOptions`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        return concreteImplementation(`application`, `launchOptions`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `application`(_ `application`: @escaping @autoclosure () -> UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: @escaping @autoclosure () -> [UIApplication.LaunchOptionsKey: Any]?) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`application`), Mockingbird.resolve(`launchOptions`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `saveContext`()

  public override func `saveContext`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`saveContext`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `saveContext`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`saveContext`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `SwiftUIApp.AppDelegate`.
public func mock(_ type: SwiftUIApp.AppDelegate.Type, file: StaticString = #file, line: UInt = #line) -> AppDelegateMock.InitializerProxy.Type {
  return AppDelegateMock.InitializerProxy.self
}

// MARK: - Mocked Assembler

public final class AssemblerMock: SwiftUIApp.Assembler, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssemblerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `SwiftUIApp.Assembler`.
public func mock(_ type: SwiftUIApp.Assembler.Type, file: StaticString = #file, line: UInt = #line) -> AssemblerMock {
  return AssemblerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Bird

public final class BirdMock: SwiftUIApp.Bird, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      BirdMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked canFly

  public var `canFly`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "canFly.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getCanFly() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "canFly.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fly`()

  public func `fly`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fly`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `fly`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fly`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `SwiftUIApp.Bird`.
public func mock(_ type: SwiftUIApp.Bird.Protocol, file: StaticString = #file, line: UInt = #line) -> BirdMock {
  return BirdMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ContactsDataSource

public final class ContactsDataSourceMock: SwiftUIApp.ContactsDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ContactsDataSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `SwiftUIApp.ContactsDataSource`.
public func mock(_ type: SwiftUIApp.ContactsDataSource.Protocol, file: StaticString = #file, line: UInt = #line) -> ContactsDataSourceMock {
  return ContactsDataSourceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ContactsListPresenter

public final class ContactsListPresenterMock: SwiftUIApp.ContactsListPresenter, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ContactsListPresenterMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`user`: SwiftUIApp.User, `getAllContacts`: SwiftUIApp.GetAllContacts, __file: StaticString = #file, __line: UInt = #line) -> ContactsListPresenterMock {
      let mock: ContactsListPresenterMock = ContactsListPresenterMock(user: `user`, getAllContacts: `getAllContacts`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`user`: SwiftUIApp.User, `getAllContacts`: SwiftUIApp.GetAllContacts)

  public required override init(`user`: SwiftUIApp.User, `getAllContacts`: SwiftUIApp.GetAllContacts) {
    super.init(user: `user`, getAllContacts: `getAllContacts`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`user`: SwiftUIApp.User, `getAllContacts`: SwiftUIApp.GetAllContacts) ", arguments: [Mockingbird.ArgumentMatcher(`user`), Mockingbird.ArgumentMatcher(`getAllContacts`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `SwiftUIApp.ContactsListPresenter`.
public func mock(_ type: SwiftUIApp.ContactsListPresenter.Type, file: StaticString = #file, line: UInt = #line) -> ContactsListPresenterMock.InitializerProxy.Type {
  return ContactsListPresenterMock.InitializerProxy.self
}

// MARK: - Mocked ContactsListViewController

public final class ContactsListViewControllerMock: SwiftUIApp.ContactsListViewController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ContactsListViewControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`presenter`: SwiftUIApp.ContactsListPresenter, __file: StaticString = #file, __line: UInt = #line) -> ContactsListViewControllerMock {
      let mock: ContactsListViewControllerMock = ContactsListViewControllerMock(presenter: `presenter`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`presenter`: SwiftUIApp.ContactsListPresenter)

  public required override init(`presenter`: SwiftUIApp.ContactsListPresenter) {
    super.init(presenter: `presenter`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`presenter`: SwiftUIApp.ContactsListPresenter) ", arguments: [Mockingbird.ArgumentMatcher(`presenter`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `SwiftUIApp.ContactsListViewController`.
public func mock(_ type: SwiftUIApp.ContactsListViewController.Type, file: StaticString = #file, line: UInt = #line) -> ContactsListViewControllerMock.InitializerProxy.Type {
  return ContactsListViewControllerMock.InitializerProxy.self
}

// MARK: - Mocked ContactsSceneAssembler

public final class ContactsSceneAssemblerMock: SwiftUIApp.ContactsSceneAssembler, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ContactsSceneAssemblerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `resolve`()

  public func `resolve`() -> SwiftUIApp.ContactsDataSource {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resolve`() -> SwiftUIApp.ContactsDataSource", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> SwiftUIApp.ContactsDataSource in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> SwiftUIApp.ContactsDataSource {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> SwiftUIApp.ContactsDataSource {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (SwiftUIApp.ContactsDataSource).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `resolve`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> SwiftUIApp.ContactsDataSource, SwiftUIApp.ContactsDataSource> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resolve`() -> SwiftUIApp.ContactsDataSource", arguments: [])
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> SwiftUIApp.ContactsDataSource, SwiftUIApp.ContactsDataSource>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `resolve`()

  public func `resolve`() -> SwiftUIApp.GetAllContacts {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resolve`() -> SwiftUIApp.GetAllContacts", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> SwiftUIApp.GetAllContacts in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> SwiftUIApp.GetAllContacts {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> SwiftUIApp.GetAllContacts {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (SwiftUIApp.GetAllContacts).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `resolve`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> SwiftUIApp.GetAllContacts, SwiftUIApp.GetAllContacts> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resolve`() -> SwiftUIApp.GetAllContacts", arguments: [])
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> SwiftUIApp.GetAllContacts, SwiftUIApp.GetAllContacts>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `resolve`(`user`: SwiftUIApp.User)

  public func `resolve`(`user`: SwiftUIApp.User) -> SwiftUIApp.ContactsListPresenter {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resolve`(`user`: SwiftUIApp.User) -> SwiftUIApp.ContactsListPresenter", arguments: [Mockingbird.ArgumentMatcher(`user`)])
    return mockingContext.didInvoke(invocation) { () -> SwiftUIApp.ContactsListPresenter in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (SwiftUIApp.User) -> SwiftUIApp.ContactsListPresenter {
        return concreteImplementation(`user`)
      } else if let concreteImplementation = implementation as? () -> SwiftUIApp.ContactsListPresenter {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (SwiftUIApp.ContactsListPresenter).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `resolve`(`user`: @escaping @autoclosure () -> SwiftUIApp.User) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (SwiftUIApp.User) -> SwiftUIApp.ContactsListPresenter, SwiftUIApp.ContactsListPresenter> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`user`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resolve`(`user`: SwiftUIApp.User) -> SwiftUIApp.ContactsListPresenter", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (SwiftUIApp.User) -> SwiftUIApp.ContactsListPresenter, SwiftUIApp.ContactsListPresenter>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `resolve`(`user`: SwiftUIApp.User)

  public func `resolve`(`user`: SwiftUIApp.User) -> SwiftUIApp.ContactsListViewController {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resolve`(`user`: SwiftUIApp.User) -> SwiftUIApp.ContactsListViewController", arguments: [Mockingbird.ArgumentMatcher(`user`)])
    return mockingContext.didInvoke(invocation) { () -> SwiftUIApp.ContactsListViewController in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (SwiftUIApp.User) -> SwiftUIApp.ContactsListViewController {
        return concreteImplementation(`user`)
      } else if let concreteImplementation = implementation as? () -> SwiftUIApp.ContactsListViewController {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (SwiftUIApp.ContactsListViewController).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `resolve`(`user`: @escaping @autoclosure () -> SwiftUIApp.User) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (SwiftUIApp.User) -> SwiftUIApp.ContactsListViewController, SwiftUIApp.ContactsListViewController> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`user`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resolve`(`user`: SwiftUIApp.User) -> SwiftUIApp.ContactsListViewController", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (SwiftUIApp.User) -> SwiftUIApp.ContactsListViewController, SwiftUIApp.ContactsListViewController>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `SwiftUIApp.ContactsSceneAssembler`.
public func mock(_ type: SwiftUIApp.ContactsSceneAssembler.Protocol, file: StaticString = #file, line: UInt = #line) -> ContactsSceneAssemblerMock {
  return ContactsSceneAssemblerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked CounterService

public final class CounterServiceMock: SwiftUIApp.CounterService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CounterServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked counter

  public var `counter`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "counter.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Int in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Int {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getCounter() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "counter.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `decrement`(_ `value`: Int)

  public func `decrement`(_ `value`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`decrement`(_ `value`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`value`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(`value`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `decrement`(_ `value`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`value`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`decrement`(_ `value`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `getCounter`()

  public func `getCounter`() -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getCounter`() -> Int", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Int in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `getCounter`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getCounter`() -> Int", arguments: [])
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `increment`(_ `value`: Int)

  public func `increment`(_ `value`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`increment`(_ `value`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`value`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(`value`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `increment`(_ `value`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`value`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`increment`(_ `value`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `SwiftUIApp.CounterService`.
public func mock(_ type: SwiftUIApp.CounterService.Protocol, file: StaticString = #file, line: UInt = #line) -> CounterServiceMock {
  return CounterServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked GetAllContacts

public final class GetAllContactsMock: SwiftUIApp.GetAllContacts, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GetAllContactsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`contactsDataSource`: SwiftUIApp.ContactsDataSource, __file: StaticString = #file, __line: UInt = #line) -> GetAllContactsMock {
      let mock: GetAllContactsMock = GetAllContactsMock(contactsDataSource: `contactsDataSource`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`contactsDataSource`: SwiftUIApp.ContactsDataSource)

  public required override init(`contactsDataSource`: SwiftUIApp.ContactsDataSource) {
    super.init(contactsDataSource: `contactsDataSource`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`contactsDataSource`: SwiftUIApp.ContactsDataSource) ", arguments: [Mockingbird.ArgumentMatcher(`contactsDataSource`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `SwiftUIApp.GetAllContacts`.
public func mock(_ type: SwiftUIApp.GetAllContacts.Type, file: StaticString = #file, line: UInt = #line) -> GetAllContactsMock.InitializerProxy.Type {
  return GetAllContactsMock.InitializerProxy.self
}

// MARK: - Mocked ImageSaver

public final class ImageSaverMock: SwiftUIApp.ImageSaver, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ImageSaverMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked `saveError`(_ `image`: UIImage, `didFinishSavingWithError` `error`: Error?, `contextInfo`: UnsafeRawPointer)

  public override func `saveError`(_ `image`: UIImage, `didFinishSavingWithError` `error`: Error?, `contextInfo`: UnsafeRawPointer) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`saveError`(_ `image`: UIImage, `didFinishSavingWithError` `error`: Error?, `contextInfo`: UnsafeRawPointer) -> Void", arguments: [Mockingbird.ArgumentMatcher(`image`), Mockingbird.ArgumentMatcher(`error`), Mockingbird.ArgumentMatcher(`contextInfo`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIImage, Error?, UnsafeRawPointer) -> Void {
        concreteImplementation(`image`, `error`, `contextInfo`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `saveError`(_ `image`: @escaping @autoclosure () -> UIImage, `didFinishSavingWithError` `error`: @escaping @autoclosure () -> Error?, `contextInfo`: @escaping @autoclosure () -> UnsafeRawPointer) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIImage, Error?, UnsafeRawPointer) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`image`), Mockingbird.resolve(`error`), Mockingbird.resolve(`contextInfo`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`saveError`(_ `image`: UIImage, `didFinishSavingWithError` `error`: Error?, `contextInfo`: UnsafeRawPointer) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIImage, Error?, UnsafeRawPointer) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `writeToPhotoAlbun`(`image`: UIImage)

  public override func `writeToPhotoAlbun`(`image`: UIImage) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`writeToPhotoAlbun`(`image`: UIImage) -> Void", arguments: [Mockingbird.ArgumentMatcher(`image`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIImage) -> Void {
        concreteImplementation(`image`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `writeToPhotoAlbun`(`image`: @escaping @autoclosure () -> UIImage) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIImage) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`image`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`writeToPhotoAlbun`(`image`: UIImage) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIImage) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `SwiftUIApp.ImageSaver`.
public func mock(_ type: SwiftUIApp.ImageSaver.Type, file: StaticString = #file, line: UInt = #line) -> ImageSaverMock.InitializerProxy.Type {
  return ImageSaverMock.InitializerProxy.self
}

// MARK: - Mocked MockCounterService

public final class MockCounterServiceMock: SwiftUIApp.MockCounterService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MockCounterServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked counter

  override public var `counter`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "counter.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Int in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Int {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "counter.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getCounter() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "counter.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  public func setCounter(_ newValue: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "counter.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `decrement`(_ `value`: Int)

  public override func `decrement`(_ `value`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`decrement`(_ `value`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`value`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(`value`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `decrement`(_ `value`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`value`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`decrement`(_ `value`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `getCounter`()

  public override func `getCounter`() -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getCounter`() -> Int", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Int in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `getCounter`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getCounter`() -> Int", arguments: [])
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `increment`(_ `value`: Int)

  public override func `increment`(_ `value`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`increment`(_ `value`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`value`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(`value`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `increment`(_ `value`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`value`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`increment`(_ `value`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `SwiftUIApp.MockCounterService`.
public func mock(_ type: SwiftUIApp.MockCounterService.Type, file: StaticString = #file, line: UInt = #line) -> MockCounterServiceMock {
  return MockCounterServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked NetworkContactsDataSource

public final class NetworkContactsDataSourceMock: SwiftUIApp.NetworkContactsDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NetworkContactsDataSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `SwiftUIApp.NetworkContactsDataSource`.
public func mock(_ type: SwiftUIApp.NetworkContactsDataSource.Type, file: StaticString = #file, line: UInt = #line) -> NetworkContactsDataSourceMock {
  return NetworkContactsDataSourceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked NotificationHandler

public final class NotificationHandlerMock: SwiftUIApp.NotificationHandler, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NotificationHandlerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked addedObservers

  override public var `addedObservers`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "addedObservers.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "addedObservers.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getAddedObservers() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "addedObservers.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setAddedObservers(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "addedObservers.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked messageReceivedCounter

  override public var `messageReceivedCounter`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "messageReceivedCounter.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Int in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Int {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "messageReceivedCounter.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getMessageReceivedCounter() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "messageReceivedCounter.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  public func setMessageReceivedCounter(_ newValue: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "messageReceivedCounter.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked message

  override public var `message`: String? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "message.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> String? in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> String? {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (String?).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "message.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getMessage() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String?, String?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "message.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String?, String?>(mock: self, invocation: invocation)
  }

  public func setMessage(_ newValue: @escaping @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "message.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `didClearData`(_ `notification`: Notification)

  public override func `didClearData`(_ `notification`: Notification) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`didClearData`(_ `notification`: Notification) -> Void", arguments: [Mockingbird.ArgumentMatcher(`notification`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Notification) -> Void {
        concreteImplementation(`notification`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `didClearData`(_ `notification`: @escaping @autoclosure () -> Notification) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Notification) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`notification`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`didClearData`(_ `notification`: Notification) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Notification) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `didReceiveData`(_ `notification`: Notification)

  public override func `didReceiveData`(_ `notification`: Notification) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`didReceiveData`(_ `notification`: Notification) -> Void", arguments: [Mockingbird.ArgumentMatcher(`notification`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Notification) -> Void {
        concreteImplementation(`notification`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `didReceiveData`(_ `notification`: @escaping @autoclosure () -> Notification) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Notification) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`notification`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`didReceiveData`(_ `notification`: Notification) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Notification) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `setupObservers`()

  public override func `setupObservers`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setupObservers`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `setupObservers`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setupObservers`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `SwiftUIApp.NotificationHandler`.
public func mock(_ type: SwiftUIApp.NotificationHandler.Type, file: StaticString = #file, line: UInt = #line) -> NotificationHandlerMock.InitializerProxy.Type {
  return NotificationHandlerMock.InitializerProxy.self
}

// MARK: - Mocked SceneDelegate

public final class SceneDelegateMock: SwiftUIApp.SceneDelegate, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SceneDelegateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked window

  override public var `window`: UIWindow? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> UIWindow? in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> UIWindow? {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (UIWindow?).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIWindow?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getWindow() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIWindow?, UIWindow?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIWindow?, UIWindow?>(mock: self, invocation: invocation)
  }

  public func setWindow(_ newValue: @escaping @autoclosure () -> UIWindow?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIWindow?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIWindow?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions)

  public override func `scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`), Mockingbird.ArgumentMatcher(`session`), Mockingbird.ArgumentMatcher(`connectionOptions`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIScene, UISceneSession, UIScene.ConnectionOptions) -> Void {
        concreteImplementation(`scene`, `session`, `connectionOptions`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `scene`(_ `scene`: @escaping @autoclosure () -> UIScene, `willConnectTo` `session`: @escaping @autoclosure () -> UISceneSession, `options` `connectionOptions`: @escaping @autoclosure () -> UIScene.ConnectionOptions) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene, UISceneSession, UIScene.ConnectionOptions) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`), Mockingbird.resolve(`session`), Mockingbird.resolve(`connectionOptions`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene, UISceneSession, UIScene.ConnectionOptions) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneDidBecomeActive`(_ `scene`: UIScene)

  public override func `sceneDidBecomeActive`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidBecomeActive`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIScene) -> Void {
        concreteImplementation(`scene`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `sceneDidBecomeActive`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidBecomeActive`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneDidDisconnect`(_ `scene`: UIScene)

  public override func `sceneDidDisconnect`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidDisconnect`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIScene) -> Void {
        concreteImplementation(`scene`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `sceneDidDisconnect`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidDisconnect`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneDidEnterBackground`(_ `scene`: UIScene)

  public override func `sceneDidEnterBackground`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidEnterBackground`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIScene) -> Void {
        concreteImplementation(`scene`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `sceneDidEnterBackground`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidEnterBackground`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneWillEnterForeground`(_ `scene`: UIScene)

  public override func `sceneWillEnterForeground`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillEnterForeground`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIScene) -> Void {
        concreteImplementation(`scene`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `sceneWillEnterForeground`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillEnterForeground`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneWillResignActive`(_ `scene`: UIScene)

  public override func `sceneWillResignActive`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillResignActive`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UIScene) -> Void {
        concreteImplementation(`scene`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `sceneWillResignActive`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillResignActive`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `SwiftUIApp.SceneDelegate`.
public func mock(_ type: SwiftUIApp.SceneDelegate.Type, file: StaticString = #file, line: UInt = #line) -> SceneDelegateMock.InitializerProxy.Type {
  return SceneDelegateMock.InitializerProxy.self
}

// MARK: - Mocked StubContactsDataSource

public final class StubContactsDataSourceMock: SwiftUIApp.StubContactsDataSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      StubContactsDataSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `SwiftUIApp.StubContactsDataSource`.
public func mock(_ type: SwiftUIApp.StubContactsDataSource.Type, file: StaticString = #file, line: UInt = #line) -> StubContactsDataSourceMock {
  return StubContactsDataSourceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TestAssembler

public final class TestAssemblerMock: SwiftUIApp.TestAssembler, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestAssemblerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `resolve`()

  public override func `resolve`() -> SwiftUIApp.ContactsDataSource {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resolve`() -> SwiftUIApp.ContactsDataSource", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> SwiftUIApp.ContactsDataSource in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> SwiftUIApp.ContactsDataSource {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> SwiftUIApp.ContactsDataSource {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (SwiftUIApp.ContactsDataSource).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `resolve`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> SwiftUIApp.ContactsDataSource, SwiftUIApp.ContactsDataSource> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resolve`() -> SwiftUIApp.ContactsDataSource", arguments: [])
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> SwiftUIApp.ContactsDataSource, SwiftUIApp.ContactsDataSource>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `SwiftUIApp.TestAssembler`.
public func mock(_ type: SwiftUIApp.TestAssembler.Type, file: StaticString = #file, line: UInt = #line) -> TestAssemblerMock {
  return TestAssemblerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Tree

public final class TreeMock: SwiftUIApp.Tree, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TreeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`with` `bird`: SwiftUIApp.Bird, __file: StaticString = #file, __line: UInt = #line) -> TreeMock {
      let mock: TreeMock = TreeMock(with: `bird`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`with` `bird`: SwiftUIApp.Bird)

  public required override init(`with` `bird`: SwiftUIApp.Bird) {
    super.init(with: `bird`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`with` `bird`: SwiftUIApp.Bird) ", arguments: [Mockingbird.ArgumentMatcher(`bird`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `shake`()

  public override func `shake`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shake`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `shake`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shake`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `SwiftUIApp.Tree`.
public func mock(_ type: SwiftUIApp.Tree.Type, file: StaticString = #file, line: UInt = #line) -> TreeMock.InitializerProxy.Type {
  return TreeMock.InitializerProxy.self
}

// MARK: - Mocked User

public final class UserMock: SwiftUIApp.User, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.12.0", "module_name": "SwiftUIApp"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UserMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `SwiftUIApp.User`.
public func mock(_ type: SwiftUIApp.User.Type, file: StaticString = #file, line: UInt = #line) -> UserMock {
  return UserMock(sourceLocation: SourceLocation(file, line))
}
